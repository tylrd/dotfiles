#!/usr/bin/env bash

function killp () {
  if (( $# == 0 ))
  then
    echo usage: killp portNumber1 portNumber2 ...
  else
    for i; do
      PROCESS=$(lsof -t -i:$i)
      if [[ $PROCESS ]]; then
        kill -9 $PROCESS
        echo "killed process $PROCESS"
      else
        echo "No process found for port $i"
      fi
    done
  fi
}

mkd() {
  mkdir -p "$@"
  cd "$@" || exit
}

# Create a data URL from a file
dataurl() {
  local mimeType
  mimeType=$(file -b --mime-type "$1")
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Syntax-highlight JSON strings or files
# echo '{"foo":42}' | j`
j() {
  jq '.'
}

# converts RSA key to single line
convert_key() {
  sed s/$/\\\\n/ | tr -d '\n'
}

# grep for running docker container names and return the first container id
dgrep() {
  if (( $# == 0 )); then
    echo "Usage: dgrep <container name>"
  else
    docker ps | awk -v container=$1 '$0~container{ print $1 }' | head -n 1
  fi
}

dssh() {
  if (( $# == 0 )); then
    echo "Usage: dssh <container name>"
  fi
  local container=$(dgrep $1)

  if [ "${container}" = "" ]; then
    echo "Could not found container matching $1"
    exit 1
  fi

  docker exec -it "${container}" /bin/bash
}

dkill() {
  if (( $# == 0 )); then
    echo "Usage: dkill <container name>"
  fi
  local container=$(dgrep $1)

  if [ "${container}" = "" ]; then
    echo "Could not found container matching $1"
    exit 1
  fi

  echo "Killing container ${container}..."
  docker kill "${container}"
}

# kill all vagrant images
kvagrant() {
  vagrant global-status | awk '/running/{ print $1 }' | xargs vagrant destroy --force
}

# must be run from terraform workspace with "bastion_public_ip" in output
tssh() {
  local ssh_user="$(cat "$HOME/.ephemeral/ssh_user")"
  local hostname

  if [ "$#" -ne 1  ]; then
    echo "Must provide 1 argument => hostname"
    return 1
  else
    hostname=$1
  fi

  local ssh_opts=(
  -o ForwardAgent=yes
  -o StrictHostKeyChecking=no
  -o UserKnownHostsFile=/dev/null
  )

  local response=$(gcloud compute instances describe bastion --format=json)

  if [ -n "$response" ]; then
    local bastion_ip=$(echo "$response" | jq -r '.networkInterfaces[].accessConfigs[].natIP')
  else
    echo "No bastion host found for $(gcloud config get-value project)"
    return 1
  fi

  local proxy_command="ssh ${ssh_opts[@]} %r@$bastion_ip -W %h:%p"
  ssh "${ssh_opts[@]}" -o ProxyCommand="$proxy_command" $ssh_user@$hostname
}

eph_init() {
  if [[ -z "$TF_BUCKET" ]]; then
    echo 'Must set environment variable $TF_BUCKET'
    return 1
  fi
  terraform init -backend-config="bucket=$TF_BUCKET"
}

glist() {
  local project=$1

  if [ -z "$project" ]; then
    project=$(gcloud config get-value project)
  fi

  echo "Instances for project: $project..."

  gcloud compute instances list --limit=100 --project="$project"
}

cook() {
  local chef_env

  if [ -n "$1" ]; then
    chef_env=$1
  else
    chef_env=$(gcloud config get-value project)
  fi

  if [ ! -d "$HOME/.chef/$chef_env"  ]; then
    echo "Not a valid option for cooking! No directory found: $HOME/.chef/$chef_env"
    return 1
  fi

  echo "You are now cooking with $chef_env! $(printf '\xF0\x9F\x8D\xB2')"
  export CHEF_ENV=$chef_env
}

gshow() {
  git show $(git log --pretty=oneline | fzf | cut -d=' ' -f1)
}

# Search for file with fzf and then open it in an editor
# If inside git directory, search in entire git repository
fzf_then_open_in_editor() {
  local file

  if git rev-parse --git-dir > /dev/null 2>&1; then
    file=$(fd --type f . $(git rev-parse --show-cdup | sed 's:/*$::') | fzf --height 40%)
  else
    file=$(fzf --height 40%)
  fi

  if [ -n "$file" ]; then
    file="$(realpath "$file")"
    ${EDITOR:-vim} "$file"
  fi
}

bind -x '"\C-t": fzf_then_open_in_editor'

cdf() {
  local file

  if git rev-parse --git-dir > /dev/null 2>&1; then
    file=$(fd . $(git rev-parse --show-cdup) | sed 's:/*$::' \
      | fzf --height 40% +m -q "$1")
  else
    file=$(fzf --height 40% +m -q "$1")
  fi

  if [ -d "$file" ]; then
    cd "$file"
  else
    file=$(dirname "$file")
    cd "$file"
  fi
}

bind -x '"\C-p": cdf'

# Change directory into top level git directory
cdup() {
  if git rev-parse --git-dir > /dev/null 2>&1; then
    cdup="$(git rev-parse --show-cdup)" && cd "${cdup:-.}"
  else
    echo "Not in git directory!"
  fi
}

fzf_search_and_open() {
  if git rev-parse --git-dir > /dev/null 2>&1; then
    line=$(rg --with-filename --no-heading --line-number ${1:-''} $(git rev-parse --show-cdup | sed 's:/*$::') | fzf)
  else
    line=$(rg --with-filename --no-heading --line-number ${1:-''} | fzf)
  fi

  if [ -n "$line" ]; then
    ${EDITOR:-vim} $(cut -d':' -f1 <<< "$line") +$(cut -d':' -f2 <<< "$line")
  fi
}

bind -x '"\C-f": fzf_search_and_open'

wiki() {
  if [ $# -eq 0 ]; then
    vim "$HOME/vimwiki/index.md"
  else
    git --git-dir="$HOME/vimwiki/.git" --work-tree="$HOME/vimwiki" "$@"
  fi
}
